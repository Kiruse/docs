---
title: "Apophis SDK Cosmos Integration"
description: "Cosmos SDK integration, with Cosmos-specific specializations."
---

Currently the only blockchain integration for the Cosmos ecosystem. Its most important export is the
`Cosmos` object:

```ts
import {
  Apophis,
  Bank,
  Cosmos,
  DefaultCosmosMiddlewares,
  LocalSigner,
} from '@apophis-sdk/cosmos';
Apophis.use(...DefaultCosmosMiddlewares);

// Get a `CosmosNetworkConfig` for the Neutron Testnet from the
// Cosmos Chain Registry: https://github.com/cosmos/chain-registry
const network = await Cosmos.getNetworkFromRegistry('neutrontestnet');

// For testing or tooling only! Strongly discouraged in a production Dapp!
// See https://github.com/kiruse/cosmos-components for a Dapp solution.
const signer = LocalSigner.fromMnemonic('...');

// Wait for WebSockets to be ready (if you plan to use them).
await Cosmos.ws(network).ready();

// Get the current block
const { block } = await Cosmos.ws(network).getBlock();
console.log(block.header.hash, block.header.height, block.header.timestamp);
// Types are deserialized: block.header.height is a bigint, and
// block.header.timestamp is a Date

// Tx factory, takes arbitrary messages in
// Note that only a small subset of messages are currently implemented
const tx = Cosmos.tx([
  new Bank.Send({
    fromAddress: signer.address(network),
    toAddress: signer.address(network),
    amount: [Cosmos.coin(1_000000n, 'untrn')],
  }),
]);

// `true` here automatically populates the tx's internal gas fee field
await tx.estimateGas(network, signer, true);

// upon signing, the tx becomes bound to the given network
await signer.sign(network, tx);

// broadcasting returns immediately and does not wait for confirmation
await tx.broadcast();

// but it waits for admission - i.e. the tx is valid, but not yet finalized
if (tx.status === 'success') {
  // You can wait for finalization like this:
  const result = await Cosmos.ws(network).expectTx(tx);
  console.log(result);
}

// no matter what, even if the tx hasn't been broadcasted yet, you can get its hash:
console.log(tx.hash);
```

Although not a hard requirement, when developing Dapps, it is useful to use the `signals` from the
`core` library:

```ts
import { signals } from '@apophis-sdk/core';

signals.network.subscribe(network => {
  console.log('Switched to network:', network);
});

signals.address.subscribe(address => {
  console.log('Active address:', address);
});
```

Using these `signals` makes it trivial to create integrations for specific frontend frameworks
without having to worry about frontend-specific usage. These signals can even be used without any
frontend framework at all, enabling you to use the same Apophis SDK for both frontend and backend
development.

## REST API
The `Cosmos` object exposes a `rest(network)` method that allows you to call RPC methods exposed
through HTTPS. The REST API is a highly generic system leveraging "virtual typing," meaning even
if an endpoint is not defined in the SDK, you can still call it using the REST API in the same
pattern as the defined endpoints, simply by converting it to `as any`.

The RPC endpoints are mapped to the recursive REST API object structure:

```ts
import { Cosmos } from '@apophis-sdk/cosmos';

const network = await Cosmos.getNetworkFromRegistry('neutrontestnet');

const { balances, pagination } = await Cosmos.rest(network).bank.v1beta1.balances['neutron1...']('GET');
console.log(balances);
```

## WebSocket API
The `Cosmos` object also exposes a `ws(network)` method that allows you to interact with the
WebSocket API of a full node. Some WebSocket endpoints have overlap with the REST API, but others
are unique to the WebSocket API. Most importantly, it abstracts block and transaction subscriptions
through the `.onBlock` and `.onTx` methods.

Beware that most public nodes enforce a strict rate limit of 5 subscriptions per client. If you
require more, you will need to run your own isolated full node. However, typically, 5 subscriptions
is enough for most Dapps.

```ts
import { Cosmos, TendermintQuery } from '@apophis-sdk/cosmos';

const network = await Cosmos.getNetworkFromRegistry('neutrontestnet');

const ws = Cosmos.ws(network);
ws.onBlock(block => {
  console.log('New block:', block.header.height);
});

let query = new TendermintQuery().exact('tx.hash', '<my-hash>');

ws.onTx(query, tx => {
  console.log('Tx confirmed:', tx.hash);
});
```

It also exposes an `expectTx` method which you can use to await the confirmation of a transaction:

```ts
const tx = Cosmos.tx([/* ... */]);

const result = await ws.expectTx(tx);
console.log(result);
```

## Tx Factory
***TODO***

### Signal Tx Factory
A `CosmosTxSignal` is an invariant that wraps a `CosmosTx` with various signals for use in a GUI.
Unlike the regular `CosmosTx`, this invariant takes a signal of messages, and automatically updates
and re-estimates the gas of the transaction when the messages change. It also periodically refreshes
the estimage to account for changes in the state of the blockchain while the user is still
contemplating their transaction.

The following example demonstrates the use of the `Cosmos.signalTx` factory method using Preact as
its frontend framework:

```ts
import { signals } from '@apophis-sdk/core';
import { Apophis, Bank, Cosmos, DefaultCosmosMiddlewares } from '@apophis-sdk/cosmos';
import { useComputed } from 'preact/signals';
import { useMemo } from 'preact/hooks';

Apophis.use(...DefaultCosmosMiddlewares);

Cosmos.getNetworkFromRegistry('neutrontestnet').then(network => {
  signals.network.value = network;
});

function MyComponent() {
  // There is no base type for messages. The only thing that matters is that the SDK knows how to
  // serialize and deserialize them, which is implemented through the middleware subsystem.
  const msgs = useComputed(() => [
    new Bank.Send({
      fromAddress: signals.address.value,
      toAddress: 'neutron1...', // e.g. your own address
      amount: [Cosmos.coin(1_000000n, 'untrn')], // 1 NTRN
    }),
  ]);

  const tx = useMemo(() => Cosmos.signalTx(msgs));

  return (
    <div>
      <button onClick={() => tx.signAndBroadcast()}>
        Send payment
      </button>
      <cosmos-gas-estimate tx={tx} />
    </div>
  );
}
```

The above `cosmos-gas-estimate` component is a custom element from the complementary
[Cosmos Components](/projects/cosmos-components) library.
